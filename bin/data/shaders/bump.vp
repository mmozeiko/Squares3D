//
attribute vec4 position;
attribute mat3 tangentBasis;
attribute vec2 texcoord;

uniform vec3 light;
uniform vec3 halfAngle;
uniform mat4 modelViewI;

varying vec2 uv;
varying vec3 lightVec;
varying vec3 halfVec;

void main()
{
    gl_Position = ftransform();
    
    vec3 pos = (gl_ModelViewMatrix * gl_LightSource[0].position).xyz;

    lightVec = normalize(gl_Position.xyz);

    pos = lightVec + (gl_ModelViewMatrix * gl_LightSource[0].position).xyz; //vec4(0,0,1,0)).xyz;
    halfVec = normalize(gl_Position.xyz);

    gl_TexCoord[0] = gl_MultiTexCoord0;
//    uv = gl_MultiTexCoord0.st;
/*
    // output vertex position
    gl_Position = gl_ModelViewProjectionMatrix * position;

    // output texture coordinates for decal and normal maps
    uv = texcoord;

    // transform light and half angle vectors by tangent basis
    lightVec = light * tangentBasis;
    halfVec = halfAngle * tangentBasis;
 
    eyeVec = modelViewI[3].xyz - position.xyz;
    eyeVec = eyeVec * tangentBasis;
*/
}

/*
!!ARBvp1.0
ATTRIB iPos         = vertex.position;
ATTRIB iNormal      = vertex.normal;
PARAM  mvinv[4]     = { state.matrix.modelview.invtrans };
PARAM  mvp[4]       = { state.matrix.mvp };
PARAM  lightDir     = state.light[0].position;
PARAM  halfDir      = state.light[0].half;
PARAM  specExp      = state.material.shininess;
PARAM  ambientCol   = state.lightprod[0].ambient;
PARAM  diffuseCol   = state.lightprod[0].diffuse;
PARAM  specularCol  = state.lightprod[0].specular;
TEMP   xfNormal, temp, dots;
OUTPUT oPos         = result.position;
OUTPUT oColor       = result.color;

# Transform the vertex to clip coordinates.
DP4   oPos.x, mvp[0], iPos;
DP4   oPos.y, mvp[1], iPos;
DP4   oPos.z, mvp[2], iPos;
DP4   oPos.w, mvp[3], iPos;

# Transform the normal to eye coordinates.
DP3   xfNormal.x, mvinv[0], iNormal;
DP3   xfNormal.y, mvinv[1], iNormal;
DP3   xfNormal.z, mvinv[2], iNormal;

# Compute diffuse and specular dot products and use LIT to compute
# lighting coefficients.
DP3   dots.x, xfNormal, lightDir;
DP3   dots.y, xfNormal, halfDir;
MOV   dots.w, specExp.x;
LIT   dots, dots;

# Accumulate color contributions.
MAD   temp, dots.y, diffuseCol, ambientCol;
MAD   oColor.xyz, dots.z, specularCol, temp;
MOV   oColor.w, diffuseCol.w;
#MOV oColor, state.lightmodel.scenecolor;

MOV result.texcoord[0], vertex.texcoord[0];
MOV result.texcoord[1], vertex.texcoord[1];

END

#PARAM mvp[4] = { state.matrix.mvp };
#
##tangent space. depends on texcoords
#TEMP temp, vpos;
#
##same procedure with the vector to the light position
#SUB temp, lightpos, vertex.position;
#DP3 result.texcoord[0].x, temp, tangent;
#DP3 result.texcoord[0].y, temp, bitangent;
#DP3 result.texcoord[0].z, temp, normal;
#MOV result.texcoord[0].w, 1.0;
#
#DP4 vpos.x, mvp[0], vertex.position;
#DP4 vpos.y, mvp[1], vertex.position;
#DP4 vpos.z, mvp[2], vertex.position;
#DP4 vpos.w, mvp[3], vertex.position;
#MOV result.position, vpos;
#
#END

*/