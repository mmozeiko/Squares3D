<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Mirrored from enet.bespin.org/Tutorial.html by HTTrack Website Copier/3.x [XR&CO'2006], Wed, 28 Jun 2006 08:32:16 GMT -->
<head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>enet: Tutorial</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index-2.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<b>tutorial.dox</b></div>
<h1><a class="anchor" name="Tutorial">Tutorial</a></h1><a class="el" href="Tutorial.html#CreateServer">Creating an ENet server</a><p>
<a class="el" href="Tutorial.html#CreateClient">Creating an ENet client</a><p>
<a class="el" href="Tutorial.html#ManageHost">Managing an ENet host</a><p>
<a class="el" href="Tutorial.html#SendingPacket">Sending a packet to an ENet peer</a><p>
<a class="el" href="Tutorial.html#Disconnecting">Disconnecting an ENet peer</a><p>
<a class="el" href="Tutorial.html#Connecting">Connecting to an ENet host</a><h2><a class="anchor" name="Initialization">
Initialization</a></h2>
Before using ENet, you must call <a class="el" href="group__global.html#ga0">enet_initialize()</a> to initialize the library. Upon program exit, you should call <a class="el" href="group__global.html#ga2">enet_deinitialize()</a> so that the library may clean up any used resources.<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> 
main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) 
{
    <span class="keywordflow">if</span> (<a class="code" href="group__global.html#ga0">enet_initialize</a> () != 0)
    {
        fprintf (stderr, <span class="stringliteral">"An error occurred while initializing ENet.\n"</span>);
        <span class="keywordflow">return</span> EXIT_FAILURE;
    }
    atexit (<a class="code" href="group__global.html#ga2">enet_deinitialize</a>);
    ...
    ...
    ...
}
</pre></div><h2><a class="anchor" name="CreateServer">
Creating an ENet server</a></h2>
Servers in ENet are constructed with <a class="el" href="group__host.html#ga0">enet_host_create()</a>. You must specify an address on which to receive data and new connections, as well as the maximum allowable numbers of connected peers. You may optionally specify the incoming and outgoing bandwidth of the server in bytes per second so that ENet may try to statically manage bandwidth resources among connected peers in addition to its dynamic throttling algorithm; specifying 0 for these two options will cause ENet to rely entirely upon its dynamic throttling algorithm to manage bandwidth.<p>
When done with a host, the host may be destroyed with <a class="el" href="group__host.html#ga1">enet_host_destroy()</a>. All connected peers to the host will be reset, and the resources used by the host will be freed.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__ENetAddress.html">ENetAddress</a> address;
    <a class="code" href="struct__ENetHost.html">ENetHost</a> * server;

    <span class="comment">/* Bind the server to the default localhost.     */</span>
    <span class="comment">/* A specific host address can be specified by   */</span>
    <span class="comment">/* enet_address_set_host (&amp; address, "x.x.x.x"); */</span>

    address.<a class="code" href="struct__ENetAddress.html#o0">host</a> = <a class="code" href="enet_8h.html#a90a16">ENET_HOST_ANY</a>;
    <span class="comment">/* Bind the server to port 1234. */</span>
    address.<a class="code" href="struct__ENetAddress.html#o1">port</a> = 1234;

    server = <a class="code" href="group__host.html#ga0">enet_host_create</a> (&amp; address <span class="comment">/* the address to bind the server host to */</span>, 
                                 32      <span class="comment">/* allow up to 32 clients and/or outgoing connections */</span>,
                                  0      <span class="comment">/* assume any amount of incoming bandwidth */</span>,
                                  0      <span class="comment">/* assume any amount of outgoing bandwidth */</span>);
    <span class="keywordflow">if</span> (server == NULL)
    {
        fprintf (stderr, 
                 <span class="stringliteral">"An error occurred while trying to create an ENet server host.\n"</span>);
        exit (EXIT_FAILURE);
    }
    ...
    ...
    ...
    <a class="code" href="group__host.html#ga1">enet_host_destroy</a>(server);
</pre></div><h2><a class="anchor" name="CreateClient">
Creating an ENet client</a></h2>
Clients in ENet are similarly constructed with <a class="el" href="group__host.html#ga0">enet_host_create()</a> when no address is specified to bind the host to. Bandwidth may be specified for the client host as in the above example. The peer count controls the maximum number of connections to other server hosts that may be simultaneously open.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__ENetHost.html">ENetHost</a> * client;

    client = <a class="code" href="group__host.html#ga0">enet_host_create</a> (NULL <span class="comment">/* create a client host */</span>,
                1 <span class="comment">/* only allow 1 outgoing connection */</span>,
                57600 / 8 <span class="comment">/* 56K modem with 56 Kbps downstream bandwidth */</span>,
                14400 / 8 <span class="comment">/* 56K modem with 14 Kbps upstream bandwidth */</span>);

    <span class="keywordflow">if</span> (client == NULL)
    {
        fprintf (stderr, 
                 <span class="stringliteral">"An error occurred while trying to create an ENet client host.\n"</span>);
        exit (EXIT_FAILURE);
    }
    ...
    ...
    ...
    <a class="code" href="group__host.html#ga1">enet_host_destroy</a>(client);
</pre></div><h2><a class="anchor" name="ManageHost">
Managing an ENet host</a></h2>
ENet uses a polled event model to notify the programmer of significant events. ENet hosts are polled for events with <a class="el" href="group__host.html#ga7">enet_host_service()</a>, where an optional timeout value in milliseconds may be specified to control how long ENet will poll; if a timeout of 0 is specified, <a class="el" href="group__host.html#ga7">enet_host_service()</a> will return immediately if there are no events to dispatch. <a class="el" href="group__host.html#ga7">enet_host_service()</a> will return 1 if an event was dispatched within the specified timeout.<p>
Currently there are only four types of significant events in ENet:<p>
An event of type ENET_EVENT_TYPE_NONE is returned if no event occurred within the specified time limit. <a class="el" href="group__host.html#ga7">enet_host_service()</a> will return 0 with this event.<p>
An event of type ENET_EVENT_TYPE_CONNECT is returned when either a new client host has connected to the server host or when an attempt to establish a connection with a foreign host has succeeded. Only the "peer" field of the event structure is valid for this event and contains the newly connected peer.<p>
An event of type ENET_EVENT_TYPE_RECEIVE is returned when a packet is received from a connected peer. The "peer" field contains the peer the packet was received from, "channelID" is the channel on which the packet was sent, and "packet" is the packet that was sent. The packet contained in the "packet" field must be destroyed with <a class="el" href="group__Packet.html#ga1">enet_packet_destroy()</a> when you are done inspecting its contents.<p>
An event of type ENET_EVENT_TYPE_DISCONNECT is returned when a connected peer has either explicitly disconnected or timed out. Only the "peer" field of the event structure is valid for this event and contains the peer that disconnected. Only the "data" field of the peer is still valid on a disconnect event and must be explicitly reset.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__ENetEvent.html">ENetEvent</a> event;
    
    <span class="comment">/* Wait up to 1000 milliseconds for an event. */</span>
    <span class="keywordflow">while</span> (<a class="code" href="group__host.html#ga7">enet_host_service</a> (client, &amp; event, 1000) &gt; 0)
    {
        <span class="keywordflow">switch</span> (event.<a class="code" href="struct__ENetEvent.html#o0">type</a>)
        {
        <span class="keywordflow">case</span> <a class="code" href="enet_8h.html#a94a47">ENET_EVENT_TYPE_CONNECT</a>:
            printf (<span class="stringliteral">"A new client connected from %x:%u.\n"</span>, 
                    event.<a class="code" href="struct__ENetEvent.html#o1">peer</a> -&gt; address.<a class="code" href="struct__ENetAddress.html#o0">host</a>,
                    event.<a class="code" href="struct__ENetEvent.html#o1">peer</a> -&gt; address.<a class="code" href="struct__ENetAddress.html#o1">port</a>);

            <span class="comment">/* Store any relevant client information here. */</span>
            event.<a class="code" href="struct__ENetEvent.html#o1">peer</a> -&gt; data = <span class="stringliteral">"Client information"</span>;

            <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> <a class="code" href="enet_8h.html#a94a49">ENET_EVENT_TYPE_RECEIVE</a>:
            printf (<span class="stringliteral">"A packet of length %u containing %s was received from %s on channel %u.\n"</span>,
                    event.<a class="code" href="struct__ENetEvent.html#o4">packet</a> -&gt; dataLength,
                    event.<a class="code" href="struct__ENetEvent.html#o4">packet</a> -&gt; data,
                    event.<a class="code" href="struct__ENetEvent.html#o1">peer</a> -&gt; data,
                    event.<a class="code" href="struct__ENetEvent.html#o2">channelID</a>);

            <span class="comment">/* Clean up the packet now that we're done using it. */</span>
            <a class="code" href="group__Packet.html#ga1">enet_packet_destroy</a> (event.<a class="code" href="struct__ENetEvent.html#o4">packet</a>);
            
            <span class="keywordflow">break</span>;
           
        <span class="keywordflow">case</span> <a class="code" href="enet_8h.html#a94a48">ENET_EVENT_TYPE_DISCONNECT</a>:
            printf (<span class="stringliteral">"%s disconected.\n"</span>, event.<a class="code" href="struct__ENetEvent.html#o1">peer</a> -&gt; data);

            <span class="comment">/* Reset the peer's client information. */</span>

            event.<a class="code" href="struct__ENetEvent.html#o1">peer</a> -&gt; data = NULL;
        }
    }
    ...
    ...
    ...
</pre></div><h2><a class="anchor" name="SendingPacket">
Sending a packet to an ENet peer</a></h2>
Packets in ENet are created with <a class="el" href="group__Packet.html#ga0">enet_packet_create()</a>, where the size of the packet must be specified. Optionally, initial data may be specified to copy into the packet.<p>
Certain flags may also be supplied to <a class="el" href="group__Packet.html#ga0">enet_packet_create()</a> to control various packet features:<p>
ENET_PACKET_FLAG_RELIABLE specifies that the packet must use reliable delivery. A reliable packet is guarenteed to be delivered, and a number of retry attempts will be made until an acknowledgement is received from the foreign host the packet is sent to. If a certain number of retry attempts is reached without any acknowledgement, ENet will assume the peer has disconnected and forcefully reset the connection. If this flag is not specified, the packet is assumed an unreliable packet, and no retry attempts will be made nor acknowledgements generated.<p>
A packet may be resized (extended or truncated) with <a class="el" href="group__Packet.html#ga2">enet_packet_resize()</a>.<p>
A packet is sent to a foreign host with <a class="el" href="group__peer.html#ga2">enet_peer_send()</a>. <a class="el" href="group__peer.html#ga2">enet_peer_send()</a> accepts a channel id over which to send the packet to a given peer. Once the packet is handed over to ENet with <a class="el" href="group__peer.html#ga2">enet_peer_send()</a>, ENet will handle its deallocation and <a class="el" href="group__Packet.html#ga1">enet_packet_destroy()</a> should not be used upon it.<p>
One may also use <a class="el" href="group__host.html#ga3">enet_host_broadcast()</a> to send a packet to all connected peers on a given host over a specified channel id, as with <a class="el" href="group__peer.html#ga2">enet_peer_send()</a>.<p>
Queued packets will be sent on a call to <a class="el" href="group__host.html#ga7">enet_host_service()</a>. Alternatively, <a class="el" href="group__host.html#ga6">enet_host_flush()</a> will send out queued packets without dispatching any events.<p>
<div class="fragment"><pre class="fragment">    <span class="comment">/* Create a reliable packet of size 7 containing "packet\0" */</span>
    <a class="code" href="struct__ENetPacket.html">ENetPacket</a> * packet = <a class="code" href="group__Packet.html#ga0">enet_packet_create</a> (<span class="stringliteral">"packet"</span>, 
                                              strlen (<span class="stringliteral">"packet"</span>) + 1, 
                                              <a class="code" href="enet_8h.html#a91a18">ENET_PACKET_FLAG_RELIABLE</a>);

    <span class="comment">/* Extend the packet so and append the string "foo", so it now */</span>
    <span class="comment">/* contains "packetfoo\0"                                      */</span>
    <a class="code" href="group__Packet.html#ga2">enet_packet_resize</a> (packet, strlen (<span class="stringliteral">"packetfoo"</span>) + 1);
    strcpy (&amp; packet -&gt; data [strlen (<span class="stringliteral">"packet"</span>)], <span class="stringliteral">"foo"</span>);
    
    <span class="comment">/* Send the packet to the peer over channel id 0. */</span>
    <span class="comment">/* One could also broadcast the packet by         */</span>
    <span class="comment">/* enet_host_broadcast (host, 0, packet);         */</span>
    <a class="code" href="group__peer.html#ga2">enet_peer_send</a> (peer, 0, packet);
    ...
    ...
    ...
    <span class="comment">/* One could just use enet_host_service() instead. */</span>
    <a class="code" href="group__host.html#ga6">enet_host_flush</a> (host);
</pre></div><h2><a class="anchor" name="Disconnecting">
Disconnecting an ENet peer</a></h2>
Peers may be gently disconnected with <a class="el" href="group__peer.html#ga10">enet_peer_disconnect()</a>. A disconnect request will be sent to the foreign host, and ENet will wait for an acknowledgement from the foreign host before finally disconnecting. An event of type ENET_EVENT_TYPE_DISCONNECT will be generated once the disconnection succeeds. Normally timeouts apply to the disconnect acknowledgement, and so if no acknowledgement is received after a length of time the peer will be forcefully disconnected.<p>
<a class="el" href="group__peer.html#ga7">enet_peer_reset()</a> will forcefully disconnect a peer. The foreign host will get no notification of a disconnect and will time out on the foreign host. No event is generated.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__ENetEvent.html">ENetEvent</a> event;
    
    <a class="code" href="group__peer.html#ga10">enet_peer_disconnect</a> (peer, 0);

    <span class="comment">/* Allow up to 3 seconds for the disconnect to succeed</span>
<span class="comment"> and drop any packets received packets.</span>
<span class="comment">     */</span>
    <span class="keywordflow">while</span> (<a class="code" href="group__host.html#ga7">enet_host_service</a> (client, &amp; event, 3000) &gt; 0)
    {
        <span class="keywordflow">switch</span> (event.<a class="code" href="struct__ENetEvent.html#o0">type</a>)
        {
        <span class="keywordflow">case</span> <a class="code" href="enet_8h.html#a94a49">ENET_EVENT_TYPE_RECEIVE</a>:
            <a class="code" href="group__Packet.html#ga1">enet_packet_destroy</a> (event.<a class="code" href="struct__ENetEvent.html#o4">packet</a>);
            <span class="keywordflow">break</span>;

        <span class="keywordflow">case</span> <a class="code" href="enet_8h.html#a94a48">ENET_EVENT_TYPE_DISCONNECT</a>:
            puts (<span class="stringliteral">"Disconnection succeeded."</span>);
            <span class="keywordflow">return</span>;
        ...
        ...
        ...
        }
    }
    
    <span class="comment">/* We've arrived here, so the disconnect attempt didn't */</span>
    <span class="comment">/* succeed yet.  Force the connection down.             */</span>
    <a class="code" href="group__peer.html#ga7">enet_peer_reset</a> (peer);
    ...
    ...
    ...
</pre></div><h2><a class="anchor" name="Connecting">
Connecting to an ENet host</a></h2>
A connection to a foreign host is initiated with <a class="el" href="group__host.html#ga2">enet_host_connect()</a>. It accepts the address of a foreign host to connect to, and the number of channels that should be allocated for communication. If N channels are allocated for use, their channel ids will be numbered 0 through N-1. A peer representing the connection attempt is returned, or NULL if there were no available peers over which to initiate the connection. When the connection attempt succeeds, an event of type ENET_EVENT_TYPE_CONNECT will be generated. If the connection attempt times out or otherwise fails, an event of type ENET_EVENT_TYPE_DISCONNECT will be generated.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="struct__ENetAddress.html">ENetAddress</a> address;
    <a class="code" href="struct__ENetEvent.html">ENetEvent</a> event;
    <a class="code" href="struct__ENetPeer.html">ENetPeer</a> *peer;

    <span class="comment">/* Connect to some.server.net:1234. */</span>
    <a class="code" href="group__Address.html#ga0">enet_address_set_host</a> (&amp; address, <span class="stringliteral">"some.server.net"</span>);
    address.<a class="code" href="struct__ENetAddress.html#o1">port</a> = 1234;

    <span class="comment">/* Initiate the connection, allocating the two channels 0 and 1. */</span>
    peer = <a class="code" href="group__host.html#ga2">enet_host_connect</a> (client, &amp; address, 2);    
    
    <span class="keywordflow">if</span> (peer == NULL)
    {
       fprintf (stderr, 
                <span class="stringliteral">"No available peers for initiating an ENet connection.\n"</span>);
       exit (EXIT_FAILURE);
    }
    
    <span class="comment">/* Wait up to 5 seconds for the connection attempt to succeed. */</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__host.html#ga7">enet_host_service</a> (client, &amp; event, 5000) &gt; 0 &amp;&amp;
        event.<a class="code" href="struct__ENetEvent.html#o0">type</a> == <a class="code" href="enet_8h.html#a94a47">ENET_EVENT_TYPE_CONNECT</a>)
    {
        puts (<span class="stringliteral">"Connection to some.server.net:1234 succeeded."</span>);
        ...
        ...
        ...
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">/* Either the 5 seconds are up or a disconnect event was */</span>
        <span class="comment">/* received. Reset the peer in the event the 5 seconds   */</span>
        <span class="comment">/* had run out without any significant event.            */</span>
        <a class="code" href="group__peer.html#ga7">enet_peer_reset</a> (peer);

        puts (<span class="stringliteral">"Connection to some.server.net:1234 failed."</span>);
    }
    ...
    ...
    ...
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Tue Mar 14 16:07:35 2006 for enet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>

<!-- Mirrored from enet.bespin.org/Tutorial.html by HTTrack Website Copier/3.x [XR&CO'2006], Wed, 28 Jun 2006 08:32:16 GMT -->
</html>
